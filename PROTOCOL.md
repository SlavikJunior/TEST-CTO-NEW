# P2P File Exchange Protocol

## Обзор

Протокол обмена файлами основан на **JSON-over-TCP** для обеспечения надежной передачи данных между устройствами в локальной сети. Протокол состоит из управляющих JSON команд и бинарной передачи файлов.

## Архитектурные решения

### Почему TCP?
- **Надежность**: Гарантированная доставка пакетов в правильном порядке
- **Контроль перегрузки**: Автоматическая адаптация скорости передачи
- **Повторная передача**: Автоматическая повторная отправка потерянных пакетов
- **Необходим для файлов**: Бинарные данные требуют целостности

### Почему JSON?
- **Простота**: Легкая сериализация/десериализация
- **Читаемость**: Упрощает отладку и логирование
- **Расширяемость**: Легко добавлять новые поля без breaking changes
- **Кроссплатформенность**: Поддержка во всех языках программирования

### Порт по умолчанию
**8888** - используется для входящих соединений

## Формат сообщений

Все управляющие сообщения передаются в формате JSON с завершающим символом новой строки (`\n`).

```json
{
  "type": "MESSAGE_TYPE",
  "data": { ... }
}
```

### Поля
- `type` (string): Тип сообщения (см. список типов ниже)
- `data` (object): Данные сообщения, специфичные для типа

## Типы сообщений

### 1. HANDSHAKE - Установка соединения

**Направление**: Клиент → Сервер

Первое сообщение при подключении для идентификации клиента.

```json
{
  "type": "HANDSHAKE",
  "data": {
    "deviceId": "unique-device-id",
    "nickname": "Устройство пользователя",
    "protocolVersion": "1.0"
  }
}
```

**Поля data**:
- `deviceId`: Уникальный идентификатор устройства
- `nickname`: Отображаемое имя устройства
- `protocolVersion`: Версия протокола (для совместимости)

**Ответ**: HANDSHAKE_ACK

```json
{
  "type": "HANDSHAKE_ACK",
  "data": {
    "deviceId": "server-device-id",
    "nickname": "Сервер",
    "status": "accepted"
  }
}
```

### 2. LIST_FILES - Запрос списка файлов

**Направление**: Клиент → Сервер

Запрашивает список файлов, доступных для скачивания.

```json
{
  "type": "LIST_FILES",
  "data": {}
}
```

**Ответ**: FILE_LIST

```json
{
  "type": "FILE_LIST",
  "data": {
    "files": [
      {
        "fileId": "file-uuid-1",
        "name": "document.pdf",
        "size": 1048576,
        "mimeType": "application/pdf",
        "relativePath": "/documents/document.pdf",
        "lastModified": 1703001234567
      },
      {
        "fileId": "file-uuid-2",
        "name": "photo.jpg",
        "size": 2097152,
        "mimeType": "image/jpeg",
        "relativePath": "/photos/photo.jpg",
        "lastModified": 1703001234890
      }
    ]
  }
}
```

**Поля файла**:
- `fileId`: Уникальный идентификатор файла
- `name`: Имя файла
- `size`: Размер в байтах
- `mimeType`: MIME тип файла
- `relativePath`: Относительный путь от корня общей папки
- `lastModified`: Unix timestamp в миллисекундах

### 3. TRANSFER_REQUEST - Запрос передачи файла

**Направление**: Клиент → Сервер

Инициирует скачивание файла.

```json
{
  "type": "TRANSFER_REQUEST",
  "data": {
    "fileId": "file-uuid-1",
    "transferId": "transfer-uuid"
  }
}
```

**Поля data**:
- `fileId`: ID запрашиваемого файла
- `transferId`: ID передачи для отслеживания прогресса

**Ответ**: TRANSFER_START или TRANSFER_ERROR

**Успешный ответ**:
```json
{
  "type": "TRANSFER_START",
  "data": {
    "transferId": "transfer-uuid",
    "fileId": "file-uuid-1",
    "fileName": "document.pdf",
    "fileSize": 1048576,
    "chunkSize": 8192
  }
}
```

**Поля data**:
- `transferId`: ID передачи
- `fileId`: ID файла
- `fileName`: Имя файла
- `fileSize`: Размер файла в байтах
- `chunkSize`: Размер блока данных в байтах

**После TRANSFER_START сервер начинает отправлять бинарные данные файла.**

### 4. TRANSFER_PROGRESS - Прогресс передачи

**Направление**: Сервер → Клиент

Периодически отправляется во время передачи (каждые N блоков).

```json
{
  "type": "TRANSFER_PROGRESS",
  "data": {
    "transferId": "transfer-uuid",
    "bytesTransferred": 524288,
    "totalBytes": 1048576,
    "percentage": 50.0
  }
}
```

**Поля data**:
- `transferId`: ID передачи
- `bytesTransferred`: Количество переданных байт
- `totalBytes`: Общий размер файла
- `percentage`: Процент завершения (0-100)

### 5. TRANSFER_COMPLETE - Завершение передачи

**Направление**: Сервер → Клиент

Отправляется после успешной передачи всех данных.

```json
{
  "type": "TRANSFER_COMPLETE",
  "data": {
    "transferId": "transfer-uuid",
    "fileId": "file-uuid-1",
    "checksum": "sha256-hash-of-file"
  }
}
```

**Поля data**:
- `transferId`: ID передачи
- `fileId`: ID файла
- `checksum`: Контрольная сумма для верификации (опционально)

**Ответ**: TRANSFER_ACK (подтверждение получения)

```json
{
  "type": "TRANSFER_ACK",
  "data": {
    "transferId": "transfer-uuid",
    "status": "completed"
  }
}
```

### 6. TRANSFER_ERROR - Ошибка передачи

**Направление**: Двунаправленное

Отправляется при возникновении ошибки во время передачи.

```json
{
  "type": "TRANSFER_ERROR",
  "data": {
    "transferId": "transfer-uuid",
    "errorCode": "FILE_NOT_FOUND",
    "message": "Файл не найден на сервере"
  }
}
```

**Поля data**:
- `transferId`: ID передачи
- `errorCode`: Код ошибки
- `message`: Человекочитаемое описание ошибки

**Коды ошибок**:
- `FILE_NOT_FOUND` - Файл не найден
- `PERMISSION_DENIED` - Нет доступа к файлу
- `STORAGE_FULL` - Недостаточно места на устройстве
- `CONNECTION_LOST` - Потеря соединения
- `INVALID_REQUEST` - Неверный формат запроса
- `TRANSFER_CANCELLED` - Передача отменена пользователем

### 7. CANCEL_TRANSFER - Отмена передачи

**Направление**: Клиент → Сервер

Отменяет активную передачу.

```json
{
  "type": "CANCEL_TRANSFER",
  "data": {
    "transferId": "transfer-uuid"
  }
}
```

**Ответ**: TRANSFER_CANCELLED

```json
{
  "type": "TRANSFER_CANCELLED",
  "data": {
    "transferId": "transfer-uuid"
  }
}
```

### 8. PING/PONG - Проверка соединения

**Направление**: Двунаправленное

Используется для проверки активности соединения.

```json
{
  "type": "PING",
  "data": {
    "timestamp": 1703001234567
  }
}
```

**Ответ**:
```json
{
  "type": "PONG",
  "data": {
    "timestamp": 1703001234567
  }
}
```

## Последовательность взаимодействия

### Типичный сценарий скачивания файла

```
Клиент                                    Сервер
  |                                          |
  |-------- HANDSHAKE ---------------------->|
  |<------- HANDSHAKE_ACK -------------------|
  |                                          |
  |-------- LIST_FILES --------------------->|
  |<------- FILE_LIST -----------------------|
  |                                          |
  |-------- TRANSFER_REQUEST --------------->|
  |<------- TRANSFER_START ------------------|
  |                                          |
  |<------- [Binary Data] -------------------|
  |<------- TRANSFER_PROGRESS ---------------|
  |<------- [Binary Data] -------------------|
  |<------- TRANSFER_PROGRESS ---------------|
  |<------- [Binary Data] -------------------|
  |                                          |
  |<------- TRANSFER_COMPLETE ---------------|
  |-------- TRANSFER_ACK ------------------->|
  |                                          |
```

### Сценарий с ошибкой

```
Клиент                                    Сервер
  |                                          |
  |-------- TRANSFER_REQUEST --------------->|
  |<------- TRANSFER_ERROR ------------------|
  |         (FILE_NOT_FOUND)                 |
  |                                          |
```

### Отмена передачи

```
Клиент                                    Сервер
  |                                          |
  |<------- [Binary Data] -------------------|
  |<------- TRANSFER_PROGRESS ---------------|
  |-------- CANCEL_TRANSFER ---------------->|
  |<------- TRANSFER_CANCELLED --------------|
  |                                          |
```

## Формат бинарных данных

После отправки `TRANSFER_START`, сервер начинает отправлять бинарные данные файла блоками фиксированного размера (`chunkSize`). Между блоками JSON сообщения не вставляются, только периодические `TRANSFER_PROGRESS`.

**Структура передачи**:
1. JSON сообщение `TRANSFER_START\n`
2. Бинарные данные (блок 1)
3. Бинарные данные (блок 2)
4. ...
5. JSON сообщение `TRANSFER_PROGRESS\n` (периодически)
6. ...
7. Бинарные данные (последний блок)
8. JSON сообщение `TRANSFER_COMPLETE\n`

## Обработка ошибок

### Таймауты
- **Handshake**: 10 секунд
- **LIST_FILES**: 30 секунд
- **TRANSFER_REQUEST**: 10 секунд
- **Передача данных**: без таймаута (отслеживание по прогрессу)

### Повторные попытки
- Автоматическая повторная попытка для сетевых ошибок (до 3 раз)
- Экспоненциальная задержка между попытками

### Закрытие соединения
- Клиент или сервер может закрыть соединение в любой момент
- При закрытии все активные передачи считаются прерванными

## Безопасность

**Текущая версия**: Без шифрования (локальная сеть)

**Будущие улучшения**:
- TLS для шифрования передачи
- Аутентификация устройств
- Цифровые подписи файлов

## Обнаружение устройств (mDNS)

Протокол использует mDNS (Multicast DNS) для автоматического обнаружения устройств в локальной сети.

**Сервис**: `_p2p-file-share._tcp.local.`

**TXT записи**:
- `deviceId`: Уникальный идентификатор
- `nickname`: Отображаемое имя
- `version`: Версия протокола

**Преимущества mDNS**:
- Нулевая конфигурация (zero-conf)
- Автоматическое обнаружение
- Поддержка на всех платформах
- Работает без центрального сервера

## Версионирование

**Текущая версия**: 1.0

При изменении протокола:
- **Major version** (1.0 → 2.0): Breaking changes
- **Minor version** (1.0 → 1.1): Обратно совместимые добавления

Устройства с разными major версиями не могут взаимодействовать.
